{"ast":null,"code":"import { __decorate } from 'tslib';\nimport { EventEmitter, Injectable, NgModule } from '@angular/core';\nimport * as ɵngcc0 from '@angular/core';\nvar NgAudioRecorderService_1;\nlet NgAudioRecorderService = NgAudioRecorderService_1 = class NgAudioRecorderService {\n  constructor() {\n    this.chunks = [];\n    this.recorderEnded = new EventEmitter();\n    this.recorderError = new EventEmitter(); // tslint:disable-next-line\n\n    this._recorderState = RecorderState.INITIALIZING;\n\n    this.appendToChunks = event => {\n      this.chunks.push(event.data);\n    };\n\n    this.recordingStopped = event => {\n      const blob = new Blob(this.chunks, {\n        type: 'audio/webm'\n      });\n      this.chunks = [];\n      this.recorderEnded.emit(blob);\n      this.clear();\n    };\n  }\n\n  static guc() {\n    return navigator.mediaDevices.getUserMedia({\n      audio: true\n    });\n  }\n\n  getUserContent() {\n    return NgAudioRecorderService_1.guc();\n  }\n\n  startRecording() {\n    if (this._recorderState === RecorderState.RECORDING) {\n      this.recorderError.emit(ErrorCase.ALREADY_RECORDING);\n    }\n\n    if (this._recorderState === RecorderState.PAUSED) {\n      this.resume();\n      return;\n    }\n\n    this._recorderState = RecorderState.INITIALIZING;\n    NgAudioRecorderService_1.guc().then(mediaStream => {\n      this.recorder = new MediaRecorder(mediaStream);\n      this._recorderState = RecorderState.INITIALIZED;\n      this.addListeners();\n      this.recorder.start();\n      this._recorderState = RecorderState.RECORDING;\n    });\n  }\n\n  pause() {\n    if (this._recorderState === RecorderState.RECORDING) {\n      this.recorder.pause();\n      this._recorderState = RecorderState.PAUSED;\n    }\n  }\n\n  resume() {\n    if (this._recorderState === RecorderState.PAUSED) {\n      this._recorderState = RecorderState.RECORDING;\n      this.recorder.resume();\n    }\n  }\n\n  stopRecording(outputFormat) {\n    this._recorderState = RecorderState.STOPPING;\n    return new Promise((resolve, reject) => {\n      this.recorderEnded.subscribe(blob => {\n        this._recorderState = RecorderState.STOPPED;\n\n        if (outputFormat === OutputFormat.WEBM_BLOB) {\n          resolve(blob);\n        }\n\n        if (outputFormat === OutputFormat.WEBM_BLOB_URL) {\n          const audioURL = URL.createObjectURL(blob);\n          resolve(audioURL);\n        }\n      }, _ => {\n        this.recorderError.emit(ErrorCase.RECORDER_TIMEOUT);\n        reject(ErrorCase.RECORDER_TIMEOUT);\n      });\n      this.recorder.stop();\n    }).catch(() => {\n      this.recorderError.emit(ErrorCase.USER_CONSENT_FAILED);\n    });\n  }\n\n  getRecorderState() {\n    return this._recorderState;\n  }\n\n  addListeners() {\n    this.recorder.ondataavailable = this.appendToChunks;\n    this.recorder.onstop = this.recordingStopped;\n  }\n\n  clear() {\n    this.recorder = null;\n    this.chunks = [];\n  }\n\n};\n\nNgAudioRecorderService.ɵfac = function NgAudioRecorderService_Factory(t) {\n  return new (t || NgAudioRecorderService)();\n};\n\nNgAudioRecorderService.ɵprov = /*@__PURE__*/ɵngcc0.ɵɵdefineInjectable({\n  token: NgAudioRecorderService,\n  factory: function (t) {\n    return NgAudioRecorderService.ɵfac(t);\n  }\n});\nvar OutputFormat = /*#__PURE__*/(() => {\n  (function (OutputFormat) {\n    OutputFormat[OutputFormat[\"WEBM_BLOB_URL\"] = 0] = \"WEBM_BLOB_URL\";\n    OutputFormat[OutputFormat[\"WEBM_BLOB\"] = 1] = \"WEBM_BLOB\";\n  })(OutputFormat || (OutputFormat = {}));\n\n  return OutputFormat;\n})();\nvar ErrorCase = /*#__PURE__*/(() => {\n  (function (ErrorCase) {\n    ErrorCase[ErrorCase[\"USER_CONSENT_FAILED\"] = 0] = \"USER_CONSENT_FAILED\";\n    ErrorCase[ErrorCase[\"RECORDER_TIMEOUT\"] = 1] = \"RECORDER_TIMEOUT\";\n    ErrorCase[ErrorCase[\"ALREADY_RECORDING\"] = 2] = \"ALREADY_RECORDING\";\n  })(ErrorCase || (ErrorCase = {}));\n\n  return ErrorCase;\n})();\nvar RecorderState = /*#__PURE__*/(() => {\n  (function (RecorderState) {\n    RecorderState[RecorderState[\"INITIALIZING\"] = 0] = \"INITIALIZING\";\n    RecorderState[RecorderState[\"INITIALIZED\"] = 1] = \"INITIALIZED\";\n    RecorderState[RecorderState[\"RECORDING\"] = 2] = \"RECORDING\";\n    RecorderState[RecorderState[\"PAUSED\"] = 3] = \"PAUSED\";\n    RecorderState[RecorderState[\"STOPPING\"] = 4] = \"STOPPING\";\n    RecorderState[RecorderState[\"STOPPED\"] = 5] = \"STOPPED\";\n  })(RecorderState || (RecorderState = {}));\n\n  return RecorderState;\n})();\nlet NgAudioRecorderModule = /*#__PURE__*/(() => {\n  let NgAudioRecorderModule = class NgAudioRecorderModule {};\n\n  NgAudioRecorderModule.ɵfac = function NgAudioRecorderModule_Factory(t) {\n    return new (t || NgAudioRecorderModule)();\n  };\n\n  NgAudioRecorderModule.ɵmod = /*@__PURE__*/ɵngcc0.ɵɵdefineNgModule({\n    type: NgAudioRecorderModule\n  });\n  NgAudioRecorderModule.ɵinj = /*@__PURE__*/ɵngcc0.ɵɵdefineInjector({\n    providers: [NgAudioRecorderService],\n    imports: [[]]\n  });\n  return NgAudioRecorderModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/*\n * Public API Surface of ng-audio-recorder\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\n\nexport { ErrorCase, NgAudioRecorderModule, NgAudioRecorderService, OutputFormat, RecorderState }; //# sourceMappingURL=ng-audio-recorder.js.map","map":null,"metadata":{},"sourceType":"module"}